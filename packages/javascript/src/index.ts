import createClient from 'openapi-fetch'

import { ERROR_NOTIFICATION_API_BASE_URL } from './constants'
import type { EnvironmentType } from './types/Environment'
import type { ErrorNotificationOptions } from './types/Options'
import type { ErrorNotificationPayload } from './types/Payload'
import type { paths } from './types/generated/schema.d.ts' // generated by openapi-typescript
import { convertToApiPayload } from './utils/caseConversion'

/**
 * Notify an error via inialum-error-notification-service.
 *
 * @param {Error} errorObject - The error object to notify.
 * @param {ErrorNotificationOptions} options - The options to configure the JavaScript SDK.
 * @param {string} options.token - The token used for authentication with the JavaScript SDK.
 * @param {string} [options.title] - The title of the notification.
 * @param {string} [options.description] - The description of the notification.
 * @param {string} options.serviceName - The name of the service that encountered the error.
 * @param {EnvironmentType} options.environment - The environment in which the error occurred.
 * @param {boolean} [options.enabled] - Whether to enable or disable the notification. Default is true.
 * @param {string[]} [options.ignoreErrors] - An array of error names to ignore.
 * @param {(error: Error, payload: ErrorNotificationPayload) => ErrorNotificationPayload | null | false | undefined} [options.beforeSend] - A function that allows you to modify the data being sent or prevent the notification from being sent by returning null/false.
 *
 * @example
 * ```ts
 * import { notifyError } from '@inialum/error-notification-service-javascript-sdk'
 *
 * try {
 * 	throw new Error('Some error occurred')
 * } catch (error) {
 *  if (error instanceof Error) {
 * 		await notifyError(error, {
 * 			token: 'dummy',
 * 			title: 'Some error occurred', // optional
 * 			description: 'The error description', // optional
 * 			serviceName: 'service-name',
 * 			environment: 'production',
 * 			enabled: isProd === true, // optional
 * 			ignoreErrors: ['TypeError', 'ReferenceError'], // optional
 * 			beforeSend: (error, payload) => {
 * 				// Modify payload
 * 				payload.title = `[Modified] ${payload.title}`;
 * 				// Return modified payload to send, or null/false to cancel
 * 				return payload;
 * 			},
 * 		})
 * 	}
 * }
 */
export const notifyError = async (
	errorObject: Error,
	{
		token,
		title,
		description,
		serviceName,
		environment,
		enabled = true,
		ignoreErrors = [],
		beforeSend,
	}: ErrorNotificationOptions,
): Promise<void> => {
	if (!enabled) {
		return
	}

	if (ignoreErrors.length > 0 && ignoreErrors.includes(errorObject.name)) {
		return
	}

	try {
		// Prepare the notification payload (in camelCase for user interaction)
		let payload: ErrorNotificationPayload = {
			title: title || errorObject.name,
			description: description || errorObject.message,
			serviceName: serviceName,
			environment,
		}

		// Call beforeSend if provided - users work with camelCase
		if (beforeSend) {
			const modifiedPayload = beforeSend(errorObject, payload)
			// If beforeSend returns null/false, don't send the notification
			if (modifiedPayload === null || modifiedPayload === false) {
				return
			}
			// If a valid payload is returned, use it
			if (modifiedPayload) {
				payload = modifiedPayload
			}
		}

		// Convert to snake_case for the API
		const apiPayload = convertToApiPayload(payload)

		const client = createClient<paths>({
			baseUrl: ERROR_NOTIFICATION_API_BASE_URL,
		})

		const { error } = await client.POST('/api/v1/notify', {
			body: apiPayload,
			headers: {
				Authorization: `Bearer ${token}`,
				'Content-Type': 'application/json',
			},
		})

		if (error) {
			console.error(error)
			throw new Error('Failed to notify error', {
				cause: error,
			})
		}
	} catch (error) {
		console.error(error)

		if (error instanceof Error) {
			throw error
		}
		throw new Error('Failed to notify error', {
			cause: error,
		})
	}
}

export type {
	ErrorNotificationOptions,
	EnvironmentType,
	ErrorNotificationPayload,
}
